#!/usr/bin/perl

# -----------------------------------------------------------------------------
#
# RBL Updater Suite
# monitor
# 2022 - John Bradley (userjack6880)
#
# Available at: https://github.com/userjack6880/rbl_updater
#
# -----------------------------------------------------------------------------
#
# This file is part of the RBL Updater Suite for use with rspamd
#
# The RBL Updater Suite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by the Free 
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
# details.
#
# You should have received a copy of the GNU General Public License along with 
# this program.  If not, see <https://www.gnu.org/licenses/>.
#
# -----------------------------------------------------------------------------

use strict;
use warnings;

use File::Tail;
use File::Basename;
use JSON;
use LWP::UserAgent;
use LWP::Protocol::https;
use DBI;

# usage sub -------------------------------------------------------------------
sub usage {
	print "\n".
	      "\tUsage:\n".
	      "\t\t./monitor\n".
	      "\n".
	      "\tThis script monitors the mail log defined in the config file in real\n".
	      "\ttime and updates the database accordingly.\n".
	      "\n".
	      "\tThere are no further options.\n".
	      "\n";
}

# load config file ------------------------------------------------------------
our ($asnlist,$iplist,$dbname,$dbhost,$dbport,$dbuser,$dbpass,$log,$version);
my $conffile = 'config.conf';

if (substr($conffile,0,1) ne '/' and substr($conffile,0,1) ne '.') { $conffile = "./$conffile"; }

if (-e File::Basename::dirname($0)."/$conffile") { $conffile = File::Basename::dirname($0)."/$conffile"; }
unless (-e $conffile) { usage(); die "Error! Could not read $conffile\n"; }

my $conftest = do $conffile;
die "$conffile could not be parsed: $@" if $@;
die "could not do $conffile: $!" if !defined $conftest;

# declare "global" variables --------------------------------------------------
my $dbh;

# BGP View Queries ------------------------------------------------------------
sub query_ip {
	my $ip = shift;
	my $result;

	my $ua = LWP::UserAgent->new(send_te => 0);
	$ua->agent("Mozilla/8.0"); # because cloudflare is a bitch
	my $req = HTTP::Request->new(
	            GET => "https://api.bgpview.io/ip/$ip",
	            [
	              'Content-Type' => "application/json"
	            ]
	          );
	my $res = $ua->request($req);
	# return error if JSON isn't returned
	if (substr($res->decoded_content,0,1) eq '<') {
		$result->{error} = 1;
		return $result;
	}
	my $data = decode_json($res->decoded_content);
	$result->{prefix} = $data->{data}{prefixes}[0]{prefix};
	$result->{prefix} = $data->{data}{rir_allocation}{prefix} if not defined($result->{prefix});
	$result->{asn} = $data->{data}{prefixes}[0]{asn}{asn};

	return $result;
}

sub query_asn {
	my $asn = shift;
	my @result;

	return @result if not defined($asn);

	my $ua = LWP::UserAgent->new(send_te => 0);
	$ua->agent("Mozilla/8.0"); # because cloudflare is a bitch
	my $req = HTTP::Request->new(
	            GET => "https://api.bgpview.io/asn/$asn/prefixes",
	            [
	              'Content-Type' => "application/json"
	            ]
	          );
	my $res = $ua->request($req);
	if (substr($res->decoded_content,0,1) eq '<') {
		$result[0] = 1;
		return @result;
	}
	my $data = decode_json($res->decoded_content);
	my $itr = 0;
	foreach my $entry (@{$data->{data}{ipv4_prefixes}}) {
		$result[$itr] = $entry->{prefix};
		$itr++;
	}

	return @result;
}

# DB Related Subroutines ------------------------------------------------------
sub db_keepalive {
	if(!$dbh->ping) {
		$dbh = DBI->connect_cached(
             "DBI:mysql:database=$dbname;host=$dbhost;port=$dbport",
             $dbuser,
             $dbpass
           ) or die "Could not connect to database!\n";
	}
}

sub add_asn {
	my $asn = shift;
	db_keepalive();
	my $sth;

	# the most severe of penalties - absolutely will have collateral damage
	# - initially based on percentage of ranges that get permabanned, only add to spam
	#   scores
	# - when threshold is reached (>50%), ASN gets banned for increasing amounts of time

	print "FLAGGED: AS$asn\n";

	# check if the ASN has been recorded
	# if it doesn't exist, put it in the database
	if ($dbh->selectrow_array("SELECT EXISTS(SELECT * FROM asn_blocklist WHERE asn = '$asn');") < 1) {

		# we need to record the ASN
		$sth = $dbh->prepare(q{
		  INSERT INTO asn_blocklist (asn, blocked_ranges, total_ranges, infractions, infractions_type, permaban)
		  VALUES (?,1,?,0,1,0);
		});

		# asn query now...
		my @ranges = query_asn($asn);
		if (!@ranges) {
			print "no ASN info!\n";
			return;
		}
		if ($ranges[0] == 1) {
			print "JSON error\n";
			return;
		}
		else {
			print "AS$asn has ".scalar(@ranges)." ranges\n";

			$sth->execute($asn,scalar(@ranges));
		}
	}
	else {
		# instead of recording the ASN, we now update the ASN record

		$sth = $dbh->prepare(q{
		  UPDATE asn_blocklist
		  SET blocked_ranges = blocked_ranges + 1
		  WHERE asn = ?;
		});
		$sth->execute($asn);

		# next, we need to count how many banned ranges are in this ASN, then determine action
		my ($banned,$total,$infractions) = $dbh->selectrow_array("SELECT blocked_ranges,total_ranges,infractions FROM asn_blocklist WHERE asn = '$asn';");
		print "AS$asn has $total ranges. $banned ranges are banned. AS$asn has $infractions infractions\n";

		# because this will never be the first time this happens, we can safey process actions here...
		# check if 50% has been exceeded
		my $percent = sprintf("%.0f",($banned/$total)*100);
		print "$percent% banned\n";

		if ($percent > 50) {
			print "threshold exceeded!\n";

			my @ranges = query_asn($asn);
			if (!@ranges) {
				print "no ASN info!\n";
				return;
			}
			if ($ranges[0] == 1) {
				print "JSON error\n";
				return;
			}
			# we need to increase the infraction count, or permaban if infraction count is exceeded
			if ($infractions == 0) {
				print "AS$asn: first infraction, 1 week ban\n";
				$sth = $dbh->prepare(q{
				  UPDATE asn_blocklist
				  SET infractions = infractions +1
				  WHERE asn = ?
				  AND permaban = 0;
				});
				$sth->execute($asn);
				$sth = $dbh->prepare(q{
				  INSERT INTO ipnet_blocklist (ip4_net, asn, infractions, infractions_type, ban_expiration, permaban)
				  VALUES (?,?,0,1,DATE_ADD(NOW(), INTERVAL 1 WEEK),0)
				  ON DUPLICATE KEY UPDATE ban_expiration = CASE
				    WHEN ban_expiration < NOW() THEN DATE_ADD(NOW(), INTERVAL 1 WEEK)
				    WHEN ban_expiration >= NOW() THEN DATE_ADD(ban_expiration, INTERVAL 1 WEEK)
				  END;
				});
			}
			elsif ($infractions == 1) {
				print "AS$asn: second infraction, 1 week ban\n";
				$sth = $dbh->prepare(q{
				  UPDATE asn_blocklist
				  SET infractions = infractions +1
				  WHERE asn = ?
				  AND permaban = 0;
				});
				$sth->execute($asn);
				$sth = $dbh->prepare(q{
				  INSERT INTO ipnet_blocklist (ip4_net, asn, infractions, infractions_type, ban_expiration, permaban)
				  VALUES (?,?,0,1,DATE_ADD(NOW(), INTERVAL 1 MONTH),0)
				  ON DUPLICATE KEY UPDATE ban_expiration = CASE
				    WHEN ban_expiration < NOW() THEN DATE_ADD(NOW(), INTERVAL 1 MONTH)
				    WHEN ban_expiration >= NOW() THEN DATE_ADD(ban_expiration, INTERVAL 1 MONTH)
				  END;
				});
			}
			else {
				print "AS$asn: third infraction, perma ban\n";
				$sth = $dbh->prepare(q{
				  UPDATE asn_blocklist
					SET permaban = 1
				  WHERE asn = ?
				  AND permaban = 0;
				});
				$sth->execute($asn);
				$sth = $dbh->prepare(q{
				  INSERT INTO ipnet_blocklist (ip4_net, asn, infractions, infractions_type, ban_expiration, permaban)
				  VALUES (?,?,0,1,NOW(),1)
				  ON DUPLICATE KEY UPDATE permaban = 1;
				});
			}
			foreach my $range (@ranges) {
				print "\tBan added for $range\n";
				$sth->execute($range,$asn);
			}
		}
	}
}

sub add_net {
	my $range = shift;
	db_keepalive();
	my $prefix = $range->{prefix};
	my $asn = $range->{asn};

	# at this point, we've gotta be cautious, as this may create collateral damage
	print "FLAGGED: $prefix\n";
	my $sth = $dbh->prepare(q{
	  INSERT INTO ipnet_blocklist (ip4_net, asn, infractions, infractions_type, ban_expiration, permaban)
		VALUES (?,?,1,1,NOW(),0)
		ON DUPLICATE KEY UPDATE infractions = infractions + 1,
	                          ban_expiration = CASE
	                            WHEN ban_expiration < NOW() THEN DATE_ADD(NOW(), INTERVAL 1 HOUR)
	                            WHEN ban_expiration >= NOW() THEN DATE_ADD(ban_expiration, INTERVAL 1 HOUR)
	                          END;
	});
	$sth->execute($prefix,$asn);

	# increment any time-based banned based on infractions...
	my $infractions = $dbh->selectrow_array("SELECT infractions FROM ipnet_blocklist WHERE ip4_net = '$prefix';");

	print "\t$infractions range infractions\n";

	if ($infractions > 24) {
		print "$prefix is now permanently banned!\n";
		# add prefix to permaban, note infraction in asn
		$sth = $dbh->prepare(q{
		  UPDATE ipnet_blocklist
		  SET permaban = 1
		  WHERE ip4_net = ?
		  AND permaban = 0;
		});
		$sth->execute($prefix);

		add_asn($asn) if $sth->rows >= 1;
	}
	else {
		if ($infractions == 3) {
			$sth = $dbh->prepare(q{
			  UPDATE ipnet_blocklist
			  SET ban_expiration = CASE
			    WHEN ban_expiration < NOW() THEN DATE_ADD(NOW(), INTERVAL 1 DAY)
			    WHEN ban_expiration >= NOW() THEN DATE_ADD(ban_expiration, INTERVAL 1 DAY)
			  END
			  where ip4_net = ?;
			});
			print "$prefix has recieved a 1 day ban\n";
		}
		if ($infractions > 3 && $infractions < 25) {
			$sth = $dbh->prepare(q{
			  UPDATE ipnet_blocklist
			  SET ban_expiration = CASE
			    WHEN ban_expiration < NOW() THEN DATE_ADD(NOW(), INTERVAL 1 WEEK)
			    WHEN ban_expiration >= NOW() THEN DATE_ADD(ban_expiration, INTERVAL 1 WEEK)
			  END
			  where ip4_net = ?;
			});
			print "$prefix has recieved a 1 week ban\n";
		}

		$sth->execute($prefix) if $infractions > 3;
	}
}

sub add_ip {
	my $ip = shift;
	db_keepalive();

	my $range = query_ip($ip);
	if (defined $range->{error}) {
		print "JSON error\n";
		return;
	}

	# simple increment, create if it doesn't exist
	print "FLAGGED: $ip\n";
	my $sth = $dbh->prepare(q{
	  INSERT INTO ip_blocklist (ip4, ip4_net, infractions, infractions_type, ban_expiration, permaban)
	  VALUES (INET_ATON(?),?,1,1,NOW(),0)
	  ON DUPLICATE KEY UPDATE infractions = infractions + 1;
	});
	$sth->execute($ip,$range->{prefix});

	# increment time-based bans, set permabans as needed
	my $infractions = $dbh->selectrow_array("SELECT infractions FROM ip_blocklist WHERE ip4 = INET_ATON('$ip');");

	print "\t$infractions infractions\n";

	# check to see if there are more than 5 address in the net that are currently banned... if so, then more severely punish the prefix
	# does not penalize for permabanned IPs
	if ($dbh->selectrow_array("SELECT COUNT(*) FROM ip_blocklist WHERE ip4_net = '$range->{prefix}' AND ban_expiration > NOW();") > 5) {
		print "\tUnusually high infraction from net $range->{prefix}. Punishing\n";

		add_net($range);
	}

	if ($infractions > 3) {
		print "$ip is now permanently banned!\n";
		# adds ip to permaban, add infraction to the IP4net
		$sth = $dbh->prepare(q{
		  UPDATE ip_blocklist 
		  SET permaban = 1
		  WHERE ip4 = INET_ATON(?)
			AND permaban = 0;
		});
		$sth->execute($ip);

		add_net($range) if $sth->rows >= 1;
	}
	else {
		if ($infractions == 1) {
			$sth = $dbh->prepare(q{
			  UPDATE ip_blocklist 
			  SET ban_expiration = CASE
			    WHEN ban_expiration < NOW() THEN DATE_ADD(NOW(), INTERVAL 1 HOUR)
			    WHEN ban_expiration >= NOW() THEN DATE_ADD(ban_expiration, INTERVAL 1 HOUR)
			  END
			  WHERE ip4 = INET_ATON(?);
			});
			print "$ip has recieved a 1hr ban\n";
		}

		if ($infractions == 2) {
			$sth = $dbh->prepare(q{
			  UPDATE ip_blocklist 
			  SET ban_expiration = CASE
			    WHEN ban_expiration < NOW() THEN DATE_ADD(NOW(), INTERVAL 6 HOUR)
			    WHEN ban_expiration >= NOW() THEN DATE_ADD(ban_expiration, INTERVAL 6 HOUR)
			  END
			  WHERE ip4 = INET_ATON(?);
			});
			print "$ip has recieved a 6hr ban\n";
		}

		if ($infractions == 3) {
			$sth = $dbh->prepare(q{
			  UPDATE ip_blocklist 
			  SET ban_expiration = CASE
			    WHEN ban_expiration < NOW() THEN DATE_ADD(NOW(), INTERVAL 12 HOUR)
			    WHEN ban_expiration >= NOW() THEN DATE_ADD(ban_expiration, INTERVAL 12 HOUR)
			  END
			  WHERE ip4 = INET_ATON(?);
			});
			print "$ip has recieved a 12hr ban\n";
		}

		$sth->execute($ip);
	}

}

# Begin Main Code -------------------------------------------------------------

print "\nRBL Updater Suite v.$version\n".
      "\tMonitor\n\n".
      "Monitoring $log\n";

# Open DB connection
$dbh = DBI->connect(
            "DBI:mysql:database=$dbname;host=$dbhost;port=$dbport",
            $dbuser,
            $dbpass
          ) or die "Could not connect to database!\n";

# monitor log file and act when proper log arrives
my $file=File::Tail->new($log);
while (defined(my $line=$file->read)) {
#open(my $file, '<', $log) or die "could not open log";
#while (my $line = <$file>) {

	# rejects by postfix are autoinfractions
	if ($line =~ /^.+NOQUEUE: reject:.+/) {
		if ($line =~ m/^.+\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}).+/) {
			add_ip($1);
		}
	}

	# rejects by rspamd might just be greylist bounces
	if ($line =~ /^.+milter-reject.+/) {
		# this will only penalize IPs that exit on the current blocklist or legit spam
		if ($line =~ /^.+BLOCKLIST.+/ || 
		    $line =~ /^.+spam.+/ ||
		    $line =~ /^.+Spam.+/ ) {
			if ($line =~ m/^.+\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}).+/) {
				add_ip($1);
			}
		}
	}
}

$dbh->disconnect;
